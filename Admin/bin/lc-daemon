#!/usr/bin/env python

"""
lc_daemon.py

Copyright (C) 2012-2013 Akira Hayakawa <ruby.wktk@gmail.com>
"""

from __future__ import with_statement
from daemon import DaemonContext

from daemon.pidfile import PIDLockFile
# or
#from daemon.pidfile import PIDLockFile

import time
import psutil

import lc_admin.dirnode as dirnode
import lc_admin.tools as tools

dc = DaemonContext(
		pidfile = PIDLockFile('/tmp/lc_daemon.pid'),
		stdout  = open('/var/log/lc_daemon_out.log', 'w', 0),
		stderr  = open('/var/log/lc_daemon_err.log', 'w+'))
				
class Daemon:
	
	def __init__(self):
		self.t = tools.table()
		self.devices = {}
		self.caches = {}
		
		for cache_id in self.t.keys():
			for device_id in self.t[cache_id]:
				self.devices[device_id] = tools.Device(device_id)
			if not cache_id:		
				continue
			self.caches[cache_id] = tools.Cache(cache_id)
			
	def update_migrate_state(self, cache_id):
		cache = self.caches[cache_id]
		intvl = cache.update_interval()
		t = int(time.time())	
		
		if (t % intvl):
			return
			
		b = True
		for device_id in self.t[cache_id]:
			device = self.devices[device_id]
			
			device.backing.update(intvl)
			
			thes = device.migrate_threshold()
			print("util %d" % (device.backing.util))
			if device.backing.util > thes:
				b = False
				
		if cache.force_migrate():
			print("force migrate")
			b = True
				
		print("allow migrarte?")		
		if b:		
			print("yes")
			# cache.lc_node.allow_migrate = 1
			dirnode.write(cache.lc_node, "allow_migrate", 1)
		else:
			print("no")
			# cache.lc_node.allow_migrate = 0
			dirnode.write(cache.lc_node, "allow_migrate", 0)

	def modulate_migration(self):
		for cache_id in self.t.keys():		
			if not cache_id:
				continue
			self.update_migrate_state(cache_id)

	def should_flush_buffer(self, cache):
		t = int(time.time())
		intvl = cache.flush_current_buffer_interval()
		if not intvl:
			return False

		if(t % intvl):
			return False

		current_val = cache.last_flushed_segment_id()
		b = (current_val == cache.last_flushed_segment_id_cached)
		cache.last_flushed_segment_id_cached = current_val
		return b

	def flush_buffer_periodically(self):
		for cache_id in self.t.keys():
			if not cache_id:
				continue
			cache = self.caches[cache_id]
			if not self.should_flush_buffer(cache):
				continue
			
			print("flush buffer (t:%d)" % (int(time.time())))
			# cache.lc_node.flush_current_buffer = 1
			dirnode.write(cache.lc_node, "flush_current_buffer", 1)
		return

	def should_commit_super_block(self, cache):
		t = int(time.time())
		intvl = cache.commit_super_block_interval()
		if not intvl:
			return False

		if(t % intvl):
			return False

		return True

	def commit_super_block_periodically(self):
		for cache_id in self.t.keys():
			if not cache_id:
				continue
			cache = self.caches[cache_id]
			if not self.should_commit_super_block(cache):
				continue
			
			print("commit super block (t:%d)" % (int(time.time())))
			# cache.lc_node.commit_super_block = 1
			dirnode.write(cache.lc_node, "commit_super_block", 1)
		return

	def loop(self):
		while True:
			print("daemon loop (t:%d)" % (int(time.time())))
			
			self.modulate_migration()
			self.flush_buffer_periodically()
			self.commit_super_block_periodically()
			
			time.sleep(1)

def run_lc_daemon():
	context = Daemon()
	context.loop()

with dc:
	run_lc_daemon()
