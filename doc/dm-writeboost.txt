dm-writeboost
=============
dm-writeboost target provides block-level log-structured caching.
It batches accepeted random writes into a big sequential write journal to a cache device.
It is like dm-cache as a cache target but the difference is that dm-writeboost focuses on writes.

Mechanism
=========

Basic
-----

Persistent Logging
------------------

Workers
=======
There are 1 foreground and 6 background workers.

Foreground
----------
It accepts bios and stores the write data to RAM buffer.
When the buffer is full, it creates a "flush job" and queues it.

Background
----------
(1) Writeboost flusher (wbflusher)
  It executes a flush job.

(2) Migrate Daemon
  It migrates, or writes back, cache data to backing store.

  If `allow_migrate` is true, it migrates without impending situation.
  Being in impending situation is that there are no room in cache device
  for writing more flush jobs.

  Migration is done batching `nr_max_batched_migration` segments at maximum
  at a time. Thus, unlike existing I/O scheduler, two dirty writes close in
  positional space but distant in time space can be merged. Writetboost is
  also a extension of I/O scheduler.

(3) Migration Modulator
  Migration while the backing store is heavily loaded grows the device queue
  longer and affects the read from the backing store.
  Migration modulator surveils the load of the backing store and turns on/off
  the migration by switching `allow_migrate`.

(4) Superblock Recorder
  Superblock is a last sector of first 1MB region in cache device containing
  what id of the segment lastly migrated. This daemon periodically updates
  the region every `update_record_interval` seconds.

(5) Sync Daemon
  This daemon forcefully writes out all the dirty data persistently every
  `sync_interval` seconds. Some careful users want to make all the writes
  persistent periodically.

(6) Barrier deadline worker (type 0 only)
  If dm-writeboost works in type 0, without persistent logging,
  barrier I/Os flagged with REQ_FUA or REQ_FLUSH can be acked lazily.
  Immediately processing these bios in foreground makes the throught worse.
  I/Os with these flags are queued and forcefully processed until `barrier_deadline_ms` passed.

Target Interface
================
All the operations are via dmsetup command.

Constructor
-----------
<type>
<essential args>*
<#optional args> <optional args>*
<#tunable args> <tunable args>* (see 'Messages')

<type>
0: volatile RAM buffer (DRAM)
1: type 0 + plog (block device)

<esential args> are different for different writeboost type.
<optional args> and <tunable args> are unordered lists of key-value pairs.

(type 0)
<essential args>
backing_dev        : Slow device holding original data blocks.
cache_dev          : Fast device holding cached data and its metadata.

<optional args>
segment_size_order : The size of RAM buffer
                     1 << n (sectors), 4 <= n <= 10
                     default 7
rambuf_pool_amount : The amount of the RAM buffer pool (kB).
                     Too fewer amount may cause waiting for new buffer
                     to become available again. But too much doesn't
		     benefit the performance.
                     default 2048

Examples:
dmsetup create writeboost-vol --table "0 $sz writeboost 0 $BACKING $CACHE"
dmsetup create writeboost-vol --table "0 $sz writeboost 0 $BACKING $CACHE \
                                       4 rambuf_pool_amount 8192 segment_size_order 8 \
				       2 allow_migrate 1"
dmsetup create writeboost-vol --table "0 $sz writeboost 0 $BACKING $CACHE \
                                       0 \
				       2 allow_migrate 1"

(type 1)
<essential args>
backing_dev
cache_dev
plog_dev_desc      : Descriptor to identify the plog device
                     (type 1: block device)

Example:
dmsetup create writeboost-vol --table "0 $sz 0 writeboost 1 $BACKING $CACHE $PLOG"

Note that cache device (and plog device if available)
will be re-formatted if the first sector of the cache device is zeroed out.

Messages
--------
(1) Setting up tunables in k-v pair style
You can tune up the behavior of writeboost via message interface.

barrier_deadline_ms (ms)
  Default: 3
  All the bios with barrier flags like REQ_FUA or REQ_FLUSH
  are guaranteed to be acked within this deadline.

allow_migrate (bool)
  default: 1
  Set to 1 to start migration.

enable_migration_modulator (bool) and migrate_threshold (%0
  default: 1 and 70
  Set to 1 to enable migration modulator. 
  Migration modulator surveils the load of backing device and sets the
  migration started if the load is lower than the `migrate_threshold`.

nr_max_batched_migration
  default: 2048 / (1 << segment_size_order)
  Number of segments to migrate in a iteration.
  This default value is set for a single hdd drive.
  If your backing device is built with multiple drives and
  thus can afford much IOPS try setting a higher value.

update_record_interval
  default: 60 (sec)
  The superblock record is updated every update_record_interval seconds.

sync_interval 
  default: 60 (sec)
  All the dirty writes are guaranteed to be persistent every this interval.

Example:
dmsetup message writeboost-vol 0 enable_migration_modulator 0

(2) Misc
clear_stat
  Clear the statistics
drop_caches
  Wait for all the dirty caches are migrated (Interruptible)

Example:
dmsetup message writeboost-vol 0 drop_caches

Status
------
<cursor pos>
<#cache blocks>
<#segments>
<current id>
<lastly flushed id>
<lastly migrated id>
<#dirty cache blocks>
<stat (w/r) x (hit/miss) x (on buffer?) x (fullsize?)>
<#not full flushed>
<#tunable args> [tunable args]
